A seguito di una prima parte teorica introduttiva, si procede in questo capitolo con la presentazione 
dell'impostazione pratica che si è voluto dare alle sperimentazioni condotte. La struttura secondo la quale verranno esposte 
le informazioni nei seguenti paragrafi ricalca la partizione logica alla base del codice sviluppato, pragmaticamente diviso 
in quattro moduli tra loro indipendenti:
\begin{itemize}
    \item Generazione dei parametri
    \item Generazione delle istanze di problemi MIP
    \item Risoluzione delle istanze di problemi
    \item Estrazione ed analisi dei risultati
\end{itemize}



%----------------------------------NEW SECTION

\section{Generazione dei parametri}
Il primo problema presentatosi è stato quello relativo all'individuamento dei parametri di flusso e distanza, in quanto 
fondamentali per la creazione di istanze del problema e conseguentemente anche per la loro risoluzione.

La prima possibilità valutata è stata la generazione di valori casuali per comporre le matrici dei parametri $A$ e $B$. 
Questa però è stato scartata fin da subito poichè utilizzare valori di tale tipologia non permette di fornire una versione 
pseudo-realistica di istanze del problema ed inoltre, non garantisce alcun tipo di uniformità nella generazione delle istanze, 
il che non ci permette di effettuare successivamente uno studio approfondito sulla loro complessità di risoluzione.

La soluzione a questo problema è stata individuata in un metodo illustrato in un articolo del professor Éric D. Taillard del 1995
\cite{TAILLARD}. Come verrà illustrato più nello specifico nella prossima sezione, il metodo utilizzato è detto Densità di
grigio, in inglese (\textit{Density of grey}). Esso, oltre a compensare i difetti del metodo di istanziamento casuale, permette
di automatizzare la creazione delle matrici dei parametri realizzando un algoritmo che richiede ai fini della generazione 
esclusivamente due valori: dimensione dell'istanza e densità utilizzata.

Come anticipato nell'introduzione, per realizzare tale processo è stato fatto uso del linguaggio di programmazione \textit{Python} 
\cite{python} e come supporto \textit{NumPy} \cite{NumPy}, una libreria open source che aggiunge supporto a grandi matrici 
e array multidimensionali insieme a una vasta collezione di funzioni matematiche di alto livello per poter operare efficientemente 
su queste strutture dati.

\subsection{Istanze Tai*c}
Le istanze Tai*C, la cui denominazione deriva dal nome del loro ideatore, sono una particolare classe di problemi di assegnamento quadratico
che si fondano sull'utilizzo del metodo di Densità di grigio, il quale può essere descritto nel seguente modo.

Al fine di ottenere una tonalità di grigio di densità pari a $m/n$ , il metodo in questione consiste nel generare una griglia 
rettangolare contenente $n = n_1 \times n_2$ caselle quadrate, $m$ delle quali sono nere e $n-m$ sono bianche. 
Giustapponendo molte di queste griglie è possibile ottenere una superficie grigia di gradazione pari a $m/n$.
Per ottenere la miglior qualità di colore, è necessario che le caselle nere, o quelle bianche, siano sparse uniformemente nella griglia.

A prova di ciò viene qui riportata un'applicazione del metodo realizzata con una delle soluzioni ottenute.
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.21]{images/Density_of_Grey.png}
    \caption{a sinistra la griglia relativa ad una soluzione ottima di un'istanza \textit{Tai36c} a densità $d=30\%$, 
             \newline a destra quella ottenuta accostando $1600$ griglie del tipo a sinistra}
    \label{fig:dnsgry}
\end{figure}

Per rendere al meglio l'idea che sta alla base del metodo, è possibile paragonare le caselle nere a degli elettroni e la griglia 
allo spazio accessibile agli elettroni. Il posizionamente di quest'ultimi deve essere effettuato in modo tale che la somma delle 
intensità delle forze di repulsione elettrostatica è minimizzata.

Nei problemi considerati, le forze $f_{rstu}$ $\(r,t \in \[1,n_1\] \; s,u \in \[1,n_2\]\)$ presenti tra le caselle $i$ e $j$
locate rispettivamente nelle posizioni della griglia di coordinate $\(r,s\)$ e $\(t,u\)$ sono definite come segue:
\begin{align*}
    f_{rstu} \, = \, \max_{v,w \,\in\, \{-1,0,1\}} \frac{1}{\(r-t+n_1 v\)^2 + \(s-u+n_2 w\)^2}
\end{align*}

Per ottenere una densità di grigio pari a $m/n$ è possibile risolvere un problema di tipo $QAP$ (assegnamento quadratico) in cui 
i parametri sono definiti nel seguente modo.
\begin{align*}
    a_{ij} \, = \, \begin{cases} 1 & \mbox{if } i \leq m \mbox{ and } j \leq m \\ 0 & \mbox{otherwise} \end{cases} 
    \qquad \;\;
    b_{ij} \,=\, b_{\; n_2 \(r-1\)+s \;\; n_2\(t-1\)+u} \,=\, f_{rstu}
\end{align*}

La $i$-esima componente $\(i\leq m\)$ di una soluzione $\pi$, $\pi_i = \pi_{n_2 \(r-1\)+s}$ fornisce la posizione in cui
deve essere posizonata una casella nera.

Nonostante la relativa semplicità di questi problemi, molti metodi risolutivi potrebbero non funzionare correttamente a causa 
dell'esistenza di più soluzioni con lo stesso valore obiettivo. Tali soluzioni posso essere ottenute scambiando la posizione 
di due caselle nere oppure attuando rotazioni, traslazioni o simmetrie delle caselle nella griglia. Queste tre infatti,
sono azioni che non mutano il valore della soluzione associata.

Questi problemi sono identificati in letteratura dalla sigla $grey$n$_1\_$n$_2\_$m e sono stati risolti pseudo-ottimamente 
fino a valori $n_1 = n_2 = 8$. Scegliendo definizioni dei parametri di distanza differenti oppure variando le scelte prese sui 
valori $n_1$, $n_2$ ed $m$ è possibile ottenere moltissime varianti del problema.

A questo punto è possibile sfruttare le definizioni degli elementi che caratterizzano questo modello, per realizzare degli algoritmi 
che generino la matrice dei flussi $A$ e quella delle distanze $B$ sulla base dei soli tre parametri richiesti, le dimensioni $n_1$ e $n_2$ 
(si ricorda queste sono in relazione con la dimensione dell'istanza $n$ nel seguente modo: $n=n_1\times n_2$) e la densità di grigio 
utilizzata $d$. 

Qui di seguito sono riportati gli pseudocodici degli algoritmi in questione insieme a quello delle eventuali funzioni che sono state 
utilizzate all'intero di essi.

\begin{algorithm}
    \caption{Matrix A generation}\label{A_gen}
    \begin{algorithmic}[1]
    \Function{A-generator}{$n, \,d$}
    \State $* \quad sia\; A = \[a_{ij}\] \quad *$
    \State $m \gets round\(n\cdot \(d/100\)\)$
    \ForAll{$i \in [0,n)$}
    \ForAll{$j \in [0,n)$}
        \If{$i<m \;\text{or}\; j<m$} \State $a_{ij} \gets 1$
        \Else \State $a_{ij} \gets 0$
        \EndIf
    \EndFor
    \EndFor
    \Return $A$
    \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Matrix B generation}\label{B_gen}
    \begin{algorithmic}[1]
    \Function{Force}{$n_1,\, n_2,\, r,\, s,\, t,\, u$}
    \State $max \gets 0$
    \ForAll{$v \in \{-1, 0, 1\}$}
    \ForAll{$w \in \{-1, 0, 1\}$}
        \State $m \gets 1\,/\(\(r-t+n_1 v\)^2 + \(s-u+n_2 w\)^2\)$
        \State $max \gets \max \(max, m\)$
    \EndFor
    \EndFor
    \Return $max$
    \EndFunction
    \BState
    \Function{B-generator}{$n_1,\, n_2$}
    \State $* \quad sia\; B = \[b_{ij}\] \,con \;valori \;inizializzati \;a \;zero \quad *$
    \State $scale \gets 100000$
    \ForAll{$r \in [0,n_1)$}
    \ForAll{$s \in [0,n_2)$}
    \ForAll{$t \in [0,n_1)$}
    \ForAll{$u \in [0,n_2)$}
        \State $i \gets n_2 \cdot \(r-1\)+s$
        \State $j \gets n_2 \cdot \(t-1\)+u$
        \If{$b_{ij} \, \neq \, 0$} \State continue
        \Else 
            \State $b_{ij} \gets \text{round} \(\text{Force}\(n_1,n_2,r,s,t,u\)\cdot scale\)$
            \State $b_{ji} \gets b_{ij}$
        \EndIf
    \EndFor
    \EndFor
    \EndFor
    \EndFor
    \Return $B$
    \EndFunction
    \end{algorithmic}
\end{algorithm}

Come si può intuire osservando lo pseudocodice del primo algoritmo, nella sua costruzione è stata presa la decisione di 
esprimere la densità $d$ in punti percentuali, ovvero $d \in \[0,100\]$. Da qui il perchè nel calcolo del valore di $m$ è necessaria 
la divisione per $100$.

Relativamente al secondo algoritmo invece, sono necessarie alcune puntualizzazioni. Alla riga n°20 si può notare come il valore della distanza 
calcolata tramite la funzione \textit{Force} non avviene direttamente ma vengono effettuate delle operazioni intermedie. Come prima cosa 
il valore ritornato dalla funzione viene scalato di un fattore \textit{scale} pari a $100000$ e successivamente viene arrotondato all'intero 
più vicino. In tale modo è stato possibile confrontare le matrici ottenute, nello specifico la \textit{Tai64c} e la \textit{Tai256c}, 
con quelle messe a disposizione dal sito web \textit{QAPLIB} \cite{QAPLIB}, una libreria online contenente diverse tipologie di istanze 
di prolemi di assegnamento quadratico tra cui la \textit{Tai*c}. Quest'operazione ha permesso in fase di costruzione dell'algoritmo di 
garantirne la correttezza. All riga n°21 invece, si sfrutta la proprietà di simmetria della matrice $B$ per risparmiare 
metà dei calcoli dei valori di distanza, riducendo così la complessità temporale dell'algoritmo. Si ricorda infatti che, date due unità 
qualsiasi, la distanza della prima dalla seconda è la medesima della seconda dalla prima.

Come si può notare sono state utilizzate due funzioni di cui non è stato riportato lo pseudocodice, \textit{max} e \textit{round}.
Questo perchè sono due funzioni elementari messe a disposizione della libreria standard di \textit{Python} \cite{python} di cui il 
funzionamento è noto. La prima richiede due valori come parametri e ritorna il massimo tra questi mentre la seconda ritorna 
l'arrotondamento all'intero più vicino del numero fornito come parametro.



%----------------------------------NEW SECTION
\newpage
\section{Generazione delle istanze di problemi MIP}
Terminata la generazione delle matrici dei parametri, costituenti il \textit{dataset} grezzo alla base di questo lavoro, è stato necessario ricavare a 
partire da ciascuna coppia di matrici $A$ e $B$ il corrispondente problema di programmazione lineare intera di assegnamento quadratico. Per fare questo è stato 
inizialmente necessario ricavare una modellazione algebrica del problema stesso, definendo variabili, vincoli e funzione obiettivo con cui 
rappresentarlo formalmente. Come sarà possibile vedere successivamente, a tale modello è stato necessario apportare diverse modifiche per renderlo
prima corretto e poi anche ottimizzato. Solo in un secondo momento è stato quindi possibile procedere con l'implementazione del modello nel software 
e la costruzione delle singole istanze, facendo uso di un'apposita libreria Python.

\subsection{Modellazione algebrica}
Un \textit{modello algebrico} di un problema di programmazione lineare intera è un modello che descrive le caratteristiche della soluzione 
ottima al problema mediante relazioni matematiche \cite{rop}. Un modello algebrico è composto dai seguenti elementi:
\begin{itemize}
\item \textsl{insiemi}, i quali racchiudono gli elementi del sistema permettendo l'indicizzazione delle grandezze trattate nel problema
\item \textsl{parametri}, ossia quantità costanti e definite nella formulazione del problema stesso, che solitamente sono delle proprietà relative agli insiemi definiti precedentemente
\item \textsl{variabili}, ossia le grandezze incognite del sistema, su cui l'algoritmo può agire (nei limiti imposti dai vincoli dal loro dominio) per ottimizzare il valore della soluzione
\item \textsl{vincoli}, ossia relazioni matematiche che permettono di verificare l'ammissibilità delle soluzioni e, di conseguenza, definire quali assegnazioni alle variabili sono accettabili nel contesto del problema e quali invece non lo sono
\item \textsl{funzione obiettivo}, che permette la traduzione di una soluzione del problema in un valore numerico, rendendone possibile di conseguenza l'ottimizzazione
\end{itemize}

Un modello algebrico di un problema di programmazione lineare permette quindi la definizione in forma dichiarativa delle caratteristiche della soluzione cercata, 
piuttosto che definire una strategia con cui eseguire la ricerca della soluzione stessa. Un modello di programmazione matematica potrebbe essere quindi paragonato 
ad un linguaggio dichiarativo, che descrive il risultato che si vuole ottenere, piuttosto che ad un linguaggio procedurale, che indica invece la sequenza di passi 
da percorrere per arrivare a quel risultato.

Durante la fase di modellazione formale del problema viene persa parte della potenza descrittiva caratteristica del linguaggio naturale, a vantaggio però della 
possibilità di utilizzare algoritmi particolarmente efficienti nella risoluzione dello stesso, che possono essere applicati solo quando il problema è definito in questa forma.

Come si vedrà nel prosieguo della trattazione, nel caso del problema analizzato in questo lavoro la modellazione algebrica non è stata di immediata risoluzione.

\noindent
Per prima cosa sono stati identificati gli insiemi del problema, ovvero
\begin{align*}
I \, &: \, \mbox{insieme delle unità (\textit{locations})}\\
U \, &: \, \mbox{insieme delle posizioni (\textit{facilities})}
\end{align*}
Per quanto riguarda l'identificazione dei parametri, quest'operazione è già stata trattata nella sezione precedente e rappresenta le 
fondamenta su cui l'istanze del problema vengono costruite. Facendo uso degli algoritmi appositamente costruiti è possibile ottenere 
tutti i parametri necessari in forma matriciale del tipo:
\begin{align*}
A = \[a_{uv}\] \quad & \mbox{con} \; a_{uv} : \, \mbox{flusso dall'unità \textit{u} all'unità \textit{v}} \\
B = \[b_{ij}\] \quad & \mbox{con} \; b_{ij} : \, \mbox{distanza dalla posizione \textit{i} alla posizione \textit{j}}
\end{align*}

Per quanto concerne le variabili del problema, queste sono indicizzate dall'insieme delle unità $I$ e da quello delle posizioni $U$ e la loro definizione è la seguente:
\begin{align*}
x_{iu} = \begin{cases}  1 & \mbox{se l'unità } i \in I \mbox{ è stata assegnata alla posizione } u \in U\\ 0 & \mbox{altrimenti} \end{cases}
\end{align*}
È stato inoltre necessario definire due vincoli per assicurare la correttezza della soluzione trovata. Il primo garantisce che ogni unità venga assagnata ad esattamente una posizione e il secondo invece, che ogni posizione sia asseganta ad esattamente un'unità.
\begin{align*}
    \sum_{i\in I} x_{iu} = 1 \quad & \forall u \in U \\
    \sum_{u\in U} x_{iu} = 1 \quad & \forall i \in I
\end{align*}

Infine, la funzione obiettivo $f(x)$, che dovrà essere minimizzata dal risolutore, viene definita come segue.
\begin{align*}
    f\(x\) \, = \, \min \, \sum_{i\in I} \sum_{u\in U} \sum_{j\in I} \sum_{v\in U} \, a_{uv}\cdot b_{ij}\cdot x_{iu}\cdot x_{jv}
\end{align*}

Il modello algebrico del problema di assegnamento quadratico ricavato, può dunque essere complessivamente definito nel seguente modo: 
\begin{align}
    \label{eq:mipqap}
	\begin{array}{l}
      \min \, \sum_{i\in I} \sum_{u\in U} \sum_{j\in I} \sum_{v\in U} \, a_{uv}\cdot b_{ij}\cdot x_{iu}\cdot x_{jv} \\
      \sum_{i\in I} \; x_{iu} = 1  \qquad \forall u \in U \\
      \sum_{u\in U} x_{iu} = 1     \qquad \forall i \in I \\
      x_{iu} \in \{0,1\}
    \end{array}
\end{align}


\subsection{Linearizzazione del modello}
Come è possibile notare, il modello algebrico ricavato precedentemente (\ref{eq:mipqap}) non rispetta completamente i canoni della 
formulazione dei problemi di programmazione lineare intera (\ref{eq:mip}). Ai fini della risoluzione del problema, è dunque necessario 
ricondurre il modello in oggetto alla formulazione \textit{MIP} apportando alcune modifiche necessarie.

Nello specifico il problema risiede nella funzione obiettivo. Come lascia intuire il nome, la programmazione lineare 
intera esige un funzione obiettivo lineare, mentre in quella del modello in questione è presente il prodotto fra incognite 
$\(x_{iu}\cdot x_{jv}\)$ che la rende non lineare.

Il problema è stato risolto effettuando un'operazione di linearizzazione. Tale processo consiste nell'introduzione di una variabile
$y_{iujv}$ che vada a sostituire il prodotto fra variabili, rendendo così lineare la funzione obiettivo.

\noindent
Tale variabile è stata definita nel seguente modo:
\begin{align*}
    y_{iujv} \, = \, x_{iu}\cdot x_{jv}
\end{align*}
Tuttavia, affinchè questa variabile sia consistente con i valori delle variabili $x_{iu}$ e $x_{jv}$ che la definiscono è stato necessario 
introdurre tre ulteriori vincoli.
\begin{align*}
    y_{iujv} \,& \leq \, x_{iu}   \;\;\;\qquad \forall \; i,j \in I ,\; u,v \in U \\ 
    y_{iujv} \,& \leq \, x_{jv}   \;\;\;\qquad \forall \; i,j \in I ,\; u,v \in U \\
    y_{iujv} \,& \geq \, x_{iu} + x_{jv} - 1 \qquad \forall \; i,j \in I ,\; u,v \in U 
\end{align*}
I vincoli sopra elencati garantiscono che la variabile $y_{iujv}$ assuma valore $1$ se e solamente se entrambe le variabili 
$x_{iu}$ e $x_{jv}$ assumono valore $1$. Nel caso in cui anche solo una di esse dovesse assumere valore $0$, anche $y_{iujv}$ 
assumerebbe valore $0$.

Pragmaticamente, la variabile qui introdotta indica se l'unità $i$ è stata assegnata alla posizione $u$ e contemporaneamente 
l'unità $j$ è stata assegnata alla posizione $v$ o meno.

Tenendo conto delle nuove modifiche e l'aggiunta dei nuovi vincoli, il modello complessivo corrisponde al seguente.
\begin{align}
    \label{eq:mipqaplin}
	\begin{array}{l}
      \min \, \sum_{i\in I} \sum_{u\in U} \sum_{j\in I} \sum_{v\in U} \, a_{uv}\cdot b_{ij}\cdot y_{iujv} \\
      \sum_{i\in I} \; x_{iu} = 1  \qquad \forall u \in U \\
      \sum_{u\in U} x_{iu} = 1     \qquad \forall i \in I \\
      y_{iujv} \, \leq \, x_{iu}   \;\;\;\qquad \forall \; i,j \in I ,\; u,v \in U \\ 
      y_{iujv} \, \leq \, x_{jv}   \;\;\;\qquad \forall \; i,j \in I ,\; u,v \in U \\
      y_{iujv} \, \geq \, x_{iu} + x_{jv} - 1      \qquad \forall \; i,j \in I ,\; u,v \in U  \\
      x_{iu} ,\, y_{iujv} \in \{0,1\}   \;\,\,\quad\qquad \forall \; i,j \in I ,\; u,v \in U
    \end{array}
\end{align}
A questo punto della trattazione è doveroso effettuare un'importante osservazione. Come si può notare la variabile principale 
presente nella funzione obiettivo, ovvero quella introdotta in questa sezione, è indicizzata da quattro elementi tutti appartenenti 
a insiemi caratterizzati dalla medesima cardinalità, che per praticità indicheremo con la lettera \textit{n}. 

Ciò implica che dato \textit{n}, numero totale delle posizioni e delle unità, vanno prese in esame $n^4$ variabili differenti 
e, come è facilmente intuibile, questo comporta pesanti conseguenze a livello di complessità computazionale nella risoluzione 
del problema. Si riportano qui di seguito alcuni esempi che evidenziano la questione.
\begin{align*}
    n=4  \;\;&\Rightarrow\;\; \mbox{n° variabili} = 4^4 = 256 \\
    n=9  \;\;&\Rightarrow\;\; \mbox{n° variabili} = 9^4 = 6561 \\
    n=16 \;\;&\Rightarrow\;\; \mbox{n° variabili} = 16^4 = 65536
\end{align*}
Nonostate la potenza computazionale non indifferente dell'hardware che è stato messo a dispozione per effettuare gli esperimenti, 
questo rapporto tra numero di variabili e cardinalità degli insiemi non permette di spingersi molto in avanti con la dimensione delle 
istanze nelle sperimentazioni. Senza apportare alcuna semplificazione al modello, non sarebbe stato possibile raccogliere dati a 
sufficienza per realizzare uno studio approfondito.

\subsection{Semplificazione del modello}
prova

\subsection{Modellazione nel software}
prova




%----------------------------------NEW SECTION

\section{Risoluzione delle istanze di problemi}
prova




%----------------------------------NEW SECTION

\section{Estrazione ed analisi dei risultati}
prova