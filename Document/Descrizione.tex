A seguito di una prima parte teorica introduttiva, si procede in questo capitolo con la presentazione 
dell'impostazione pratica che si è voluto dare alle sperimentazioni condotte. La struttura secondo la quale verranno esposte 
le informazioni nei seguenti paragrafi ricalca la partizione logica alla base del codice sviluppato, pragmaticamente diviso 
in quattro moduli tra loro indipendenti:
\begin{itemize}
    \item Generazione dei parametri
    \item Generazione delle istanze di problemi MIP
    \item Risoluzione delle istanze di problemi
    \item Estrazione ed analisi dei risultati
\end{itemize}



%----------------------------------NEW SECTION

\section{Generazione dei parametri}
Il primo problema presentatosi è stato quello relativo all'individuamento dei parametri di flusso e distanza, in quanto 
fondamentali per la creazione di istanze del problema e conseguentemente anche per la loro risoluzione.

La prima possibilità valutata è stata la generazione di valori casuali per comporre le matrici dei parametri $A$ e $B$. 
Questa però è stato scartata fin da subito poichè utilizzare valori di tale tipologia non permette di fornire una versione 
pseudo-realistica di istanze del problema ed inoltre, non garantisce alcun tipo di uniformità nella generazione delle istanze, 
il che non ci permette di effettuare successivamente uno studio approfondito sulla loro complessità di risoluzione.

La soluzione a questo problema è stata individuata in un metodo illustrato in un articolo del professor Éric D. Taillard del 1995
\cite{TAILLARD}. Come verrà illustrato più nello specifico nella prossima sezione, il metodo utilizzato è detto Densità di
grigio, in inglese (\textit{Density of grey}). Esso, oltre a compensare i difetti del metodo di istanziamento casuale, permette
di automatizzare la creazione delle matrici dei parametri realizzando un algoritmo che richiede ai fini della generazione 
esclusivamente due valori: dimensione dell'istanza e densità utilizzata.

Come anticipato nell'introduzione, per realizzare tale processo è stato fatto uso del linguaggio di programmazione \textit{Python} 
\cite{python} e come supporto \textit{NumPy} \cite{NumPy}, una libreria open source che aggiunge supporto a grandi matrici 
e array multidimensionali insieme a una vasta collezione di funzioni matematiche di alto livello per poter operare efficientemente 
su queste strutture dati.

\subsection{Istanze Tai*c}
Le istanze Tai*C, la cui denominazione deriva dal nome del loro ideatore, sono una particolare classe di problemi di assegnamento quadratico
che si fondano sull'utilizzo del metodo di Densità di grigio, il quale può essere descritto nel seguente modo.

Al fine di ottenere una tonalità di grigio di densità pari a $m/n$ , il metodo in questione consiste nel generare una griglia 
rettangolare contenente $n = n_1 \times n_2$ caselle quadrate, $m$ delle quali sono nere e $n-m$ sono bianche. 
Giustapponendo molte di queste griglie è possibile ottenere una superficie grigia di gradazione pari a $m/n$.
Per ottenere la miglior qualità di colore, è necessario che le caselle nere, o quelle bianche, siano sparse uniformemente nella griglia.

A prova di ciò viene qui riportata un'applicazione del metodo realizzata con una delle soluzioni ottenute.
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.21]{images/Density_of_Grey.png}
    \caption{a sinistra la griglia relativa ad una soluzione ottima di un'istanza \textit{Tai36c} a densità $d=30\%$, 
             \newline a destra quella ottenuta accostando $1600$ griglie del tipo a sinistra}
    \label{fig:dnsgry}
\end{figure}

Per rendere al meglio l'idea che sta alla base del metodo, è possibile paragonare le caselle nere a degli elettroni e la griglia 
allo spazio accessibile agli elettroni. Il posizionamente di quest'ultimi deve essere effettuato in modo tale che la somma delle 
intensità delle forze di repulsione elettrostatica è minimizzata.

Nei problemi considerati, le forze $f_{rstu}$ $\(r,t \in \[1,n_1\] \; s,u \in \[1,n_2\]\)$ presenti tra le caselle $i$ e $j$
locate rispettivamente nelle posizioni della griglia di coordinate $\(r,s\)$ e $\(t,u\)$ sono definite come segue:
\begin{align*}
    f_{rstu} \, = \, \max_{v,w \,\in\, \{-1,0,1\}} \frac{1}{\(r-t+n_1 v\)^2 + \(s-u+n_2 w\)^2}
\end{align*}

Per ottenere una densità di grigio pari a $m/n$ è possibile risolvere un problema di tipo $QAP$ (assegnamento quadratico) in cui 
i parametri sono definiti nel seguente modo.
\begin{align*}
    a_{ij} \, = \, \begin{cases} 1 & \mbox{if } i \leq m \mbox{ and } j \leq m \\ 0 & \mbox{otherwise} \end{cases} 
    \qquad \;\;
    b_{ij} \,=\, b_{\; n_2 \(r-1\)+s \;\; n_2\(t-1\)+u} \,=\, f_{rstu}
\end{align*}

La $i$-esima componente $\(i\leq m\)$ di una soluzione $\pi$, $\pi_i = \pi_{n_2 \(r-1\)+s}$ fornisce la posizione in cui
deve essere posizonata una casella nera.

Nonostante la relativa semplicità di questi problemi, molti metodi risolutivi potrebbero non funzionare correttamente a causa 
dell'esistenza di più soluzioni con lo stesso valore obiettivo. Tali soluzioni posso essere ottenute scambiando la posizione 
di due caselle nere oppure attuando rotazioni, traslazioni o simmetrie delle caselle nella griglia. Queste tre infatti,
sono azioni che non mutano il valore della soluzione associata.

Questi problemi sono identificati in letteratura dalla sigla $grey$n$_1\_$n$_2\_$m e sono stati risolti pseudo-ottimamente 
fino a valori $n_1 = n_2 = 8$. Scegliendo definizioni dei parametri di distanza differenti oppure variando le scelte prese sui 
valori $n_1$, $n_2$ ed $m$ è possibile ottenere moltissime varianti del problema.

A questo punto è possibile sfruttare le definizioni degli elementi che caratterizzano questo modello, per realizzare degli algoritmi 
che generino la matrice dei flussi $A$ e quella delle distanze $B$ sulla base dei soli tre parametri richiesti, le dimensioni $n_1$ e $n_2$ 
(si ricorda queste sono in relazione con la dimensione dell'istanza $n$ nel seguente modo: $n=n_1\times n_2$) e la densità di grigio 
utilizzata $d$. 

Qui di seguito sono riportati gli pseudocodici degli algoritmi in questione insieme a quello delle eventuali funzioni che sono state 
utilizzate all'intero di essi.

\begin{algorithm}
    \caption{Matrix A generation}\label{A_gen}
    \begin{algorithmic}[1]
    \Function{A-generator}{$n, \,d$}
    \State $* \quad sia\; A = \[a_{ij}\] \quad *$
    \State $m \gets round\(n\cdot \(d/100\)\)$
    \ForAll{$i \in [0,n)$}
    \ForAll{$j \in [0,n)$}
        \If{$i<m \;\text{or}\; j<m$} \State $a_{ij} \gets 1$
        \Else \State $a_{ij} \gets 0$
        \EndIf
    \EndFor
    \EndFor
    \Return $A$
    \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Matrix B generation}\label{B_gen}
    \begin{algorithmic}[1]
    \Function{Force}{$n_1,\, n_2,\, r,\, s,\, t,\, u$}
    \State $max \gets 0$
    \ForAll{$v \in \{-1, 0, 1\}$}
    \ForAll{$w \in \{-1, 0, 1\}$}
        \State $m \gets 1\,/\(\(r-t+n_1 v\)^2 + \(s-u+n_2 w\)^2\)$
        \State $max \gets \max \(max, m\)$
    \EndFor
    \EndFor
    \Return $max$
    \EndFunction
    \BState
    \Function{B-generator}{$n_1,\, n_2$}
    \State $* \quad sia\; B = \[b_{ij}\] \,con \;valori \;inizializzati \;a \;zero \quad *$
    \State $scale \gets 100000$
    \ForAll{$r \in [0,n_1)$}
    \ForAll{$s \in [0,n_2)$}
    \ForAll{$t \in [0,n_1)$}
    \ForAll{$u \in [0,n_2)$}
        \State $i \gets n_2 \cdot \(r-1\)+s$
        \State $j \gets n_2 \cdot \(t-1\)+u$
        \If{$b_{ij} \, \neq \, 0$} \State continue
        \Else 
            \State $b_{ij} \gets \text{round} \(\text{Force}\(n_1,n_2,r,s,t,u\)\cdot scale\)$
            \State $b_{ji} \gets b_{ij}$
        \EndIf
    \EndFor
    \EndFor
    \EndFor
    \EndFor
    \Return $B$
    \EndFunction
    \end{algorithmic}
\end{algorithm}

Come si può intuire osservando lo pseudocodice del primo algoritmo, nella sua costruzione è stata presa la decisione di 
esprimere la densità $d$ in punti percentuali, ovvero $d \in \[0,100\]$. Da qui il perchè nel calcolo del valore di $m$ è necessaria 
la divisione per $100$.

Relativamente al secondo algoritmo invece, sono necessarie alcune puntualizzazioni. Alla riga n°10 si può notare come il valore della distanza 
calcolata tramite la funzione \textit{Force} non avviene direttamente ma vengono effettuate delle operazioni intermedie. Come prima cosa 
il valore ritornato dalla funzione viene scalato di un fattore \textit{scale} pari a $100000$ e successivamente viene arrotondato all'intero 
più vicino. In tale modo è stato possibile confrontare le matrici ottenute, nello specifico la \textit{Tai64c} e la \textit{Tai256c}, 
con quelle messe a disposizione dal sito web \textit{QAPLIB} \cite{QAPLIB}, una libreria online contenente diverse tipologie di istanze 
di prolemi di assegnamento quadratico tra cui la \textit{Tai*c}. Quest'operazione ha permesso in fase di costruzione dell'algoritmo di 
garantirne la correttezza. All riga n°21 invece, si sfrutta la proprietà di simmetria della matrice $B$ per risparmiare 
metà dei calcoli dei valori di distanza, riducendo così la complessità temporale dell'algoritmo. Si ricorda infatti che, date due unità 
qualsiasi, la distanza della prima dalla seconda è la medesima della seconda dalla prima.

Come si può notare sono state utilizzate due funzioni di cui non è stato riportato lo pseudocodice, \textit{max} e \textit{round}.
Questo perchè sono due funzioni elementari messe a disposizione della libreria standard di \textit{Python} \cite{python} di cui il 
funzionamento è noto. La prima richiede due valori come parametri e ritorna il massimo tra questi mentre la seconda ritorna 
l'arrotondamento all'intero più vicino del numero fornito come parametro.



%----------------------------------NEW SECTION
\newpage
\section{Generazione delle istanze di problemi MIP}
Terminata la generazione delle matrici dei parametri, costituenti il \textit{dataset} grezzo alla base di questo lavoro, è stato necessario ricavare a 
partire da ciascuna coppia di matrici $A$ e $B$ il corrispondente problema di programmazione lineare intera di assegnamento quadratico. Per fare questo è stato 
inizialmente necessario ricavare una modellazione algebrica del problema stesso, definendo variabili, vincoli e funzione obiettivo con cui 
rappresentarlo formalmente. Come sarà possibile vedere successivamente, a tale modello è stato necessario apportare diverse modifiche per renderlo
prima corretto e poi anche ottimizzato. Solo in un secondo momento è stato quindi possibile procedere con l'implementazione del modello nel software 
e la costruzione delle singole istanze, mediante l'ausilio di un'apposita libreria Python.

\subsection{Modellazione algebrica}
Un \textit{modello algebrico} di un problema di programmazione lineare intera è un modello che descrive le caratteristiche della soluzione 
ottima al problema mediante relazioni matematiche \cite{rop}. Un modello algebrico è composto dai seguenti elementi:
\begin{itemize}
\item \textsl{insiemi}, che racchiudono gli elementi del sistema permettendo l'indicizzazione delle grandezze trattate nel problema
\item \textsl{parametri}, ossia quantità costanti e definite nella formulazione del problema stesso, che solitamente sono delle proprietà relative agli insiemi definiti precedentemente
\item \textsl{variabili}, ossia le grandezze incognite del sistema, su cui l'algoritmo può agire (nei limiti imposti dai vincoli dal loro dominio) per ottimizzare il valore della soluzione
\item \textsl{vincoli}, ossia relazioni matematiche che permettono di verificare l'ammissibilità delle soluzioni e, di conseguenza, definire quali assegnazioni alle variabili sono accettabili nel contesto del problema e quali invece non lo sono
\item \textsl{funzione obiettivo}, che permette la traduzione di una soluzione del problema in un valore numerico, rendendone possibile di conseguenza l'ottimizzazione
\end{itemize}

Un modello algebrico di un problema di programmazione lineare permette quindi la definizione in forma dichiarativa delle caratteristiche della soluzione cercata, 
piuttosto che definire una strategia con cui eseguire la ricerca della soluzione stessa. Un modello di programmazione matematica potrebbe essere quindi paragonato 
ad un linguaggio dichiarativo, che descrive il risultato che si vuole ottenere, piuttosto che ad un linguaggio procedurale, che indica invece la sequenza di passi 
da percorrere per arrivare a quel risultato.

Durante la fase di modellazione formale del problema viene persa parte della potenza descrittiva caratteristica del linguaggio naturale, a vantaggio però della 
possibilità di utilizzare algoritmi particolarmente efficienti nella risoluzione dello stesso, che possono essere applicati solo quando il problema è definito in questa forma.

//DA CAMBIARE !!

La modellazione algebrica non è stata, nel caso del problema analizzato in questo lavoro, particolarmente onerosa.

\noindent
Per prima cosa sono stati identificati gli insiemi del problema, ovvero
\begin{align*}
V \,  : \, \mbox{insieme dei vertici del grafo}\\
E \, : \, \mbox{insieme degli archi del grafo}
\end{align*}
Successivamente, è stato necessario identificare i parametri del problema. Avendo studiato la formulazione \textit{unweighted} del problema di vertex cover, in cui tutti i vertici hanno un peso associato $c_v=1$, non è stato necessario definire alcun parametro.  Infine sono state definite le variabili del problema, indicizzate dall'insieme dei vertici $V$
\begin{align*}
x_v = \begin{cases}  1 & \mbox{se il vertice } v \in V \mbox{ è compreso nel vertex cover} \\ 0 & \mbox{altrimenti} \end{cases}
\end{align*}
In questo caso il vincolo imposto dal problema è uno solo, ossia che almeno uno dei due vertici collegati da un arco sia presente nel vertex cover, per ognuno degli archi del grafo. Questo vincolo può essere rappresentato in forma dichiarativa mediante le variabili e gli insiemi precedentemente definiti come
\begin{align*}
x_u + x_v \geq 1 \quad \forall (u,v) \in E,  u \in V, v \in V
\end{align*}
La definizione della funzione obiettivo $f(x)$, che dovrà essere minimizzata dal risolutore,  viene a questo punto naturale
\vspace{-0.5cm}
\begin{align*}
f(x) = \sum_{v \in V} x_v
\end{align*}
Il modello algebrico del problema di programmazione lineare del minimo vertex cover può quindi essere complessivamente definito come 
\begin{align}
    \label{eq:mipprob}
	\begin{array}{l}
      min\, (\sum_{v \in V} x_v)\\
      x_u + x_v \geq 1  \qquad \forall (u,v) \in E,  u \in V, v \in V \\
      x_v \in {0,1}  \qquad \forall v \in V 
    \end{array}
\end{align}

\subsection{Linearizzazione del modello}
prova

\subsection{Semplificazione del modello}
prova

\subsection{Modellazione nel software}
prova




%----------------------------------NEW SECTION

\section{Risoluzione delle istanze di problemi}
prova




%----------------------------------NEW SECTION

\section{Estrazione ed analisi dei risultati}
prova